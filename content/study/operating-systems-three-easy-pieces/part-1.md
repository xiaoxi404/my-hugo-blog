---
title: "Cpu Virtualization Part 1"
date: 2022-04-10T19:38:25+08:00
draft: false
slug: cpu-virtualization-1
---

# 第4章 抽象：进程

时分共享CPU技术：操作系统通过让一个进程只运行一个时间片，然后切换到其他进程，提供了存在多个虚拟CPU的假象。

空分共享：资源在空间上被划分给希望使用它的人。例如，磁盘空间自然是一个空分共享资源，因为一旦将块分配给文件，在用户删除文件之前，不可能将它分配给其他文件。

## 4.1 抽象进程

进程：操作系统为正在运行的程序提供的抽象

## 4.2 进程API

- 创建（create）：操作系统必须包含一些创建进程的方法。在shell中键入命令或双击应用程序图标时，会调用操作系统来创建新进程，运行指定的程序。
- 销毁（destroy）：由于存在创建进程的接口，因此系统还提供了一个强制销毁进程的接口。
- 等待（wait）：有时等待进程停止运行是有用的，因此经常提供某种等待接口。
- 其他控制（miscellaneous control）：除了杀死或等待进程外，有时还可能有其他控制。例如，大多数操作系统提供某种方法来暂停进程（停止运行一段时间），然后恢复（继续运行）。
- 状态（status）：通常也有一些接口可以获得有关进程的状态信息，例如运行了多长时间，或者处于什么状态。

## 4.3 进程创建：更多细节

操作系统第一步将代码和所有静态数据（例如初始化变量）加载（load）到内存中，加载到进程的地址空间。 现代操作系统惰性（lazily）执行该过程，即仅在程序执行期间需要加载的代码或数据片段，才会加载。

操作系统还需要执行一些其他操作。必须为程序的运行时站（run-time stack 或 stack）分配一些内存。C程序使用栈存放局部变量、函数参数和返回地址。操作系统分配这些内存，并提供给进程。

操作系统也可能为程序的堆（heap）分配一些内存。在 C 程序中，堆用于显式请求的动态分配数据。程序通过调用 malloc()来请求这样的空间，并通过调用 free()来明确地释放它。

操作系统还将执行一些其他初始化任务，特别是输入/输出（I/O）相关的任务。例如，在 UNIX 系统中，默认情况下每个进程都有 3 个打开的文件描述符（file descriptor），用于标准输入、输出和错误。这些描述符让程序轻松读取来自终端的输入以及打印输出到屏幕。

## 4.4 进程状态

- 运行（running）：在运行状态下，进程正在处理器上运行。这意味着它正在执行指令。
- 就绪（ready）：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统选择不在此时运行。
- 堵塞（blocked）：在堵塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。一个常见例子：当进程向磁盘发起I/O请求时，它会被阻塞，因此其他进程可以使用处理器。

![进程：状态切换](https://b2.xiaoxi404.com/img/%E8%BF%9B%E7%A8%8B%E8%BD%AC%E6%8D%A2.webp)

## 4.5 数据结构

操作系统有一些关键的数据结构来跟踪各种相关的信息。例如，为了跟踪每个进程的状态，操作系统可能会为所有就绪的进程保留某种进程列表（process list），以及跟踪当前正在运行的进程的一些附加信息。操作系统还必须以某种方式跟踪被阻塞的进程。当 I/O 事件完成时，操作系统应确保唤醒正确的进程，让它准备好再次运行。

进程还有初始（initial）和最终（final）两种状态，前者代表进程在创建时处于的状态，后者代表程序处于已退出但尚未清理的最终状态（final）状态。

## 4.6 小结

我们已经了解了操作系统的最基本抽象：进程。他很简单地被视为一个正在进行的程序。

# 第5章 插叙：进程API

UNIX系统采用了一种非常有趣的创建新进程的方式，即通过一对系统调用：fork()和exec()。进程还可以通过第三个系统调用wait()，来等待其创建的子进程执行完成。

## 5.1 fork()系统调用

进程调用fork()系统调用，这是操作系统提供的创建新进程的方法。新创建的进程几乎与调用进程完全一样，对操作系统来说，这时看起来有两个完全一样的程序在运行，并都从 fork()系统调用中返回。新创建的进程称为子进程（child），原来的进程称为父进程（parent）。子进程不会从 main()函数开始执行，而是直接从 fork()系统调用返回，就好像是它自己调用了 fork()。

子进程并不是完全拷贝了父进程。具体来说，虽然它拥有自己的地址空间（即拥有自己的私有内存）、寄存器、程序计数器等，但是它从 fork()返回的值是不同的。父进程获得的返回值是新创建子进程的 PID，而子进程获得的返回值是 0。这个差别非常重要。

## 5.2 wait()系统调用

父进程调用 wait()，延迟自己的执行，直到子进程执行完毕。

## 5.3 最后是exec()系统调用

exec()系统调用可以让子进程执行与父进程不同的程序。

exec()与fork()是有区别的。给定可执行程序的名称及需要的参数后，exec()会从可执行程序中加载代码和静态数据，并用它覆写自己的代码段（以及静态资源数据），堆、栈及其他内存空间也会被重新初始化。然后操作系统就执行该程序，将参数通过argv传递给该进程。因此，他没有创建新进程，而是直接将当前运行的程序替换为不同的运行程序。

## 5.4 为什么这样设计API

这种分离fork()及exec()的做法在构建UNIX shell的时候非常有用，因为这给了shell在fork之后exec之前运行代码的机会，这些代码可以在运行新程序前改变环境，从而让一系列有趣的功能很容易实现。

shell 也是一个用户程序，它首先显示一个提示符（prompt），然后等待用户输入。你可以向它输入一个命令（一个可执行程序的名称及需要的参数），大多数情况下，shell可以谁文件系统中找到这个可执行程序，调用fork()创建新进程，并调用exec()的某个变体来执行这个可执行程序，调用wait()等待该命令完成。子进程执行结束后，shell从wait()返回并再次输出一个提示符，等待用户输入下一条命令。

## 5.5 其他API

在UNIX中还有其他很多与进程交互的方式。比如可以通过kill()系统调用向进程发送信号（signal），包括要求进程睡眠、终止或其他有用的指令。实际上，整个信号子系统提供了一套丰富的向进程传递外部事件的途径，包括接受和执行这些信号。

## 5.6 小结

本章介绍了在UNIX系统中创建进程需要的API：fork()，exec()和wait()。